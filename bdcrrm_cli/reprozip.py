#
# This file is part of Brazil Data Cube Reproducible Research Management CLI.
# Copyright (C) 2021 INPE.
#
# Brazil Data Cube Reproducible Research Management CLI is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.
#

"""Reprozip Wrapper."""

from bdcrrm_cli.config import EnvironmentConfig
import os

import uuid
from typing import Dict, List

from rpaths import Path
from ruamel.yaml import YAML

from reprozip.pack import pack
from reprozip.tracer import trace
from reprounzip.common import RPZPack


def _generate_uuid() -> str:
    """Generate a valid UUID4"""
    return str(uuid.uuid4())


def _filter_none_values(values: List) -> List:
    """Remove none values from an list of values

    Args:
        values (List): List of values
    Returns:
        List: Filtered list
    """
    return list(
        filter(
            lambda x: x is not None, values
        )
    )


def _exclude_execution_input_files_by_already_generated_files(reprozip_execution_config: Dict,
                                                              already_generated_files: List[str]) -> Dict:
    """Remove files/directories from the configuration file based on already generated files.

    In the bdcrrm-cli the reprozip is being used as a basis for script execution. The outputs are
    inserted into the graph and used for the connection operations of each of these. To prevent a
    file that is generated in a previous step of the execution from being included in the package,
    this function filters and removes from the configuration file, all entries that are already
    generated in previous steps.

    Args:
        reprozip_execution_config (Dict): The ReproZip execution metadata (`config.yml`) dict object.

        already_generated_files (List[str]): Files that already is generated by previous graph execution steps.

    Returns:
        Dict: The ReproZip execution metadata (`config.yml`) dict object filtered by already generated files.

    Note:
        The filtering is done in the `other_files` section of the ReproZip configuration file. Thus, the reference to
        which input data should be used is still kept in the file.
    """
    for already_generated_file in already_generated_files:
        for idx, other_file in enumerate(reprozip_execution_config["other_files"]):

            # ToDo: Do this verification by a checksum.
            if already_generated_file == other_file:
                reprozip_execution_config["other_files"][idx] = None

    # remove all "None" values
    reprozip_execution_config["other_files"] = _filter_none_values(reprozip_execution_config["other_files"])
    return reprozip_execution_config


def _exclude_execution_input_files_by_datasources(reprozip_execution_config: Dict,
                                                  datasources: Dict[str, str]) -> Dict:
    """Remove files/directories from the configuration file based on `datasources` definitions.

    Using the files in the `other_files` section of the ReproZip configuration file as a basis,
    for all data that is below the directories defined as datasources, the removal is done if
    the user has determined this way.

    Args:
        reprozip_execution_config (Dict): The ReproZip execution metadata (`config.yml`) dict object.

        datasources (List[Dict[str, str]]): The datasources definitions. This definition is a dictionary in
        which each key is the name of a datasource. The content associated with each key is a dictionary
        with `path` and `action` fields. These respectively indicate the path to the directory and the
        action to be taken (`exclude` or `include`). If the action is `exclude`, the directory is not
        included in the generated Repropack. An example of `datasource` is:

            {
                "datasource1": {
                    "path": "/path/to/datasource1/",
                    "action": "exclude"
                }
            }

    Returns:
        Dict: The ReproZip execution metadata (`config.yml`) dict object filtered by the `datasources` definitions.

    Note:
        The `other_files` section of the reprozip configuration file (config.yaml) is used because it
        contains the information about files/directories that are not attached to any OS package.
        Thus data files are kept in this section.
    """
    for datasource_key in datasources.keys():
        datasource = datasources[datasource_key]
        datasource_path = Path(datasource["path"])

        for idx, other_file in enumerate(reprozip_execution_config["other_files"]):
            other_file_path = Path(other_file)

            if other_file_path.lies_under(datasource_path):
                if datasource["action"] == "exclude":
                    reprozip_execution_config["other_files"][idx] = None

    # remove all "None" values
    reprozip_execution_config["other_files"] = _filter_none_values(reprozip_execution_config["other_files"])
    return reprozip_execution_config


def filter_reprozip_config_files(repropack_directory: str, datasources: dict,
                                 already_generated_files: List[str]):
    """Delete configuration file contents from the execution performed by ReproZip.

    Args:
        repropack_directory: The directory where the ReproZip execution files is saved.

        datasources (List[Dict[str, str]]): The datasources definitions. This definition is a dictionary in
        which each key is the name of a datasource. The content associated with each key is a dictionary
        with `path` and `action` fields. These respectively indicate the path to the directory and the
        action to be taken (`exclude` or `include`). If the action is `exclude`, the directory is not
        included in the generated Repropack. An example of `datasource` is:

            {
                "datasource1": {
                    "path": "/path/to/datasource1/",
                    "action": "exclude"
                }
            }

        already_generated_files (List[str]): Files that already is generated by previous graph execution steps.

    Returns:
        None: The filter modifications is saved in the ReproZip execution metadata (`config.yml`) file.
    """

    config_file = os.path.join(repropack_directory, "config.yml")
    reprozip_execution_config = YAML().load(open(config_file))

    # exclude files that are already generated
    if already_generated_files:
        reprozip_execution_config = (
            _exclude_execution_input_files_by_already_generated_files(
                reprozip_execution_config, already_generated_files
            )
        )

    # exclude files that are defined as datasources
    if datasources:
        reprozip_execution_config = _exclude_execution_input_files_by_datasources(reprozip_execution_config,
                                                                                  datasources)

    # write the new config file
    with open(config_file, "w") as f:
        YAML().dump(reprozip_execution_config, f)


def _extract_execution_input_by_working_dir(reprozip_execution_config: Dict,
                                            working_directories: List[str]) -> List[Dict]:
    """Extract the execution input by working directory.

    This function filters the input files defined by ReproZip.
    Args:
        reprozip_execution_config (Dict): The ReproZip execution metadata (`config.yml`) dict object.

        working_directories (List[str]): The working directories used to filter the execution input.

    Returns:
        List[Dict]: The execution input files filtered by working directory.

    Note:
        The filter is done based on `working_directories`. Therefore, all files inside these directories are considered.
        This heuristic is used to prevent invalid files (e.g., binaries, system libraries) from being used as "input data".
    """
    inputs = []
    for working_directory in working_directories:
        for input_output_file in reprozip_execution_config["inputs_outputs"]:

            if working_directory in input_output_file["path"]:
                # verify if file is a input (written by nobody - ReproZip heuristic)
                if len(input_output_file["written_by_runs"]) == 0:
                    inputs.append(input_output_file)
    return inputs


def _extract_execution_output(reprozip_execution_config: Dict) -> List[Dict]:
    """Extract the execution output by working directory.

    Args:
        reprozip_execution_config (Dict): The ReproZip execution metadata (`config.yml`) dict object.

    Returns:
        List[Dict]: The execution output files.
    """
    outputs = []
    for input_output_file in reprozip_execution_config["inputs_outputs"]:
        if len(input_output_file["written_by_runs"]) != 0:
            outputs.append(input_output_file)
    return outputs


def _extract_command(reprozip_execution_config: Dict) -> List[str]:
    """Extract the execution command.

    Args:
        reprozip_execution_config (Dict): The ReproZip execution metadata (`config.yml`) dict object.

    Returns:
        List[str]: The execution command.
    """

    # in bdcrrm, the reprozip execution strategy always generate a unique execution per command
    return reprozip_execution_config["runs"][0]["argv"]


def reprozip_execution_metadata(repropack_directory: str, working_directories: List[str]):
    """Extract the execution metadata from a ReproZip pack.

    Args:
        repropack_directory: The directory where the ReproZip execution files is saved.

        working_directories (List[str]): The working directories used to filter the execution input.

    Returns:
        Dict: The execution metadata with the following fields:
            - `repropack`: The path to the ReproZip Pack file;
            - `command`: The execution command;
            - `inputs`: The execution input files;
            - `outputs`: The execution output files;
    """

    # ToDo: Maybe this filter function is temporary. In the future, the complete object will be used.
    def _extract_path(input_output_config: str):
        """Extract only `path` key from input/output ReproZip directory."""

        return list(
            map(
                lambda obj: obj["path"], input_output_config
            )
        )

    pack_path = os.path.join(repropack_directory, "pack.rpz")
    reprozip_execution_config = YAML().load(RPZPack(pack_path).open_config())

    return {
        "repropack": pack_path,
        "command": _extract_command(reprozip_execution_config),
        "inputs": _extract_path(
            _extract_execution_input_by_working_dir(reprozip_execution_config, working_directories)
        ),
        "outputs": _extract_path(
            _extract_execution_output(reprozip_execution_config)
        )
    }


def reprozip_execute_script(reprofiles_directory: str, binary_command: str, arguments: List[str],
                            verbosity: str = "unset") -> str:
    """Execute a script using ReproZip engine.

    Args:
        reprofiles_directory: The directory where the `bdcrrm` files will be saved.

        binary_command (str): The binary command to execute the script.

        arguments (List[str]): The arguments to pass to the `binary_command`.

        verbosity (str): The verbosity level to use.

    Returns:
        str: The `repropack` directory where ReproZip trace saves the execution files.
    """

    repropack_directory = os.path.join(reprofiles_directory, EnvironmentConfig.REPROPACK_EXEC_PATH, _generate_uuid())
    os.makedirs(repropack_directory)

    # tracing the execution!
    trace.trace(binary_command, arguments, repropack_directory, False, verbosity)

    # write reprozip configuration file
    trace.write_configuration(Path(repropack_directory), True, True, overwrite=False)

    return repropack_directory


def reprozip_pack_execution(repropack_directory: str) -> str:
    """Create a ReproZip package for an experiment.

    Retrieves the execution information stored in `repropack_directory` and generates the package. If needed the files
    can be filtered using the `bdcrrm_cli.repropzip.filter_reprozip_config_files` function.

    Args:
        repropack_directory: The directory where the ReproZip execution files is saved.

    Returns:
        str: Directory where the reprozip package is saved.
    """
    repropack_pack_directory = os.path.join(repropack_directory, "pack.rpz")
    pack(Path(repropack_pack_directory), Path(repropack_directory), True)

    return repropack_pack_directory


__all__ = (
    "reprozip_execute_script",
    "reprozip_pack_execution",
    "reprozip_execution_metadata",

    "filter_reprozip_config_files"
)
