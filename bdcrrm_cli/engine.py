#
# This file is part of Brazil Data Cube Reproducible Research Management CLI.
# Copyright (C) 2021 INPE.
#
# Brazil Data Cube Reproducible Research Management CLI is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.
#

"""Brazil Data Cube Reproducible Research Management Executor Engine."""

import os

import shutil
from typing import Dict, List
from tempfile import mkdtemp

import plumbum
from .reprozip import reprozip_execute_script, reprozip_execution_metadata, reprozip_pack_execution

from .config import EnvironmentConfig
from .graph import ExecutionGraphManager, VertexStatus

from .persistence import GraphPersistencePickle


class ExecutionEngine(object):
    """Execution Engine."""

    def __init__(self, working_dir: str, reprofiles_directory: str,
                 additional_working_directories: List[str] = None, excluded_paths: List[str] = None,
                 datasources: Dict[str, Dict] = None):
        """Initialize execution engine.

        Args:
            working_dir (str): Path of the current working directory.

            reprofiles_directory (str): Path to the reprofiles directory.

            additional_working_directories (List[str]): List of additional working directories.

            excluded_paths (List[str]): List of paths that is excluded on reprozip package generation.

            datasources (Dict[str, Dict]): Definition of datasource that should be considered when building the
            reprozip package. When not set, all files are saved.

        Note:
            The working directories are used in determining which are the input and output files of the experiment being
            performed. By default, only the `working_dir` directory is used. Different directories that must be considered are
            declared through the `additional_working_directories` argument.
        """
        self._working_dir = working_dir
        self._reprofiles_directory = reprofiles_directory

        self._metadata_dir = os.path.join(self._working_dir, EnvironmentConfig.REPROPACK_BASE_PATH)

        self._datasources = datasources
        self._excluded_paths = excluded_paths

        self._additional_working_directories = (
            [working_dir, *additional_working_directories] if additional_working_directories else [self._working_dir]
        )

        self._graph_manager = self._load_graph_manager()  # what about this ?

    def _remove_unused_execution_files(self):
        """Remove execution files that are not linked to any vertex."""

        # get files from execution directory
        execution_files_stored_dir = os.path.join(self._metadata_dir, EnvironmentConfig.REPROPACK_EXEC_PATH)
        execution_files_stored = os.listdir(execution_files_stored_dir)

        # get the registered files
        execution_files_valid_on_graph = self._graph_manager.to_frame(dim="vertex")
        execution_files_valid_on_graph = execution_files_valid_on_graph["repropack"]

        # only the basename
        execution_files_stored = list(map(os.path.basename, execution_files_stored))
        execution_files_valid_on_graph = list(map(lambda x: x.split(os.sep)[-2], execution_files_valid_on_graph))

        # get the symmetric difference to define the files to remove
        execution_files_to_remove = set(execution_files_stored).symmetric_difference(
            set(execution_files_valid_on_graph))

        # remove the files
        for execution_file in execution_files_to_remove:
            shutil.rmtree(
                os.path.join(execution_files_stored_dir, execution_file)
            )

    def _load_graph_manager(self) -> ExecutionGraphManager:
        """Load the Execution Graph Manager linked to the executions.

        Returns:
            ExecutionGraphManager: Execution graph.
        """
        return ExecutionGraphManager(GraphPersistencePickle.load_graph(self._metadata_dir))

    def _save_graph_manager(self, graph_manager: ExecutionGraphManager):
        """Save the Execution Graph Manager linked to the executions.

        Args:
            graph_manager (ExecutionGraphManager): Execution Graph Manager instance.
        """
        GraphPersistencePickle.save_graph(graph_manager.graph, self._metadata_dir)

    def _filter_input_files_in_config_file(self, repropack_directory: str) -> None:
        """Filter the files that have been identified as input by ReproZip.

        Checks all identified files and excludes those that fit one or more of the patterns listed below:
            - 1. It is an input file generated by a previous step that is already in the graph. This heuristic uses the
                 maxim that for reproducibility, only the code and the input data are sufficient to obtain the same results.

            - 2. File is contained in the directory, pattern or file declared as `exclude`.

        Args:
            repropack_directory (str): Path to the reprozip directory.

        Returns:
            None: the configuration file (config.yml) into `repropack_directory` is updated.
        """
        import itertools
        from .reprozip import filter_reprozip_config_files

        # in the first execution, the graph don't have any attributes
        if not self._graph_manager.graph.attributes():
            output_generated_by_graph_vertices = []
        else:
            output_generated_by_graph_vertices = list(itertools.chain(*self._graph_manager.graph.vs["outputs"]))
        filter_reprozip_config_files(repropack_directory, self._datasources, output_generated_by_graph_vertices)

    def execute(self, command: str, remove_previous_execution_files: bool = True):
        """Execute a User Defined Command with ReproZip Trace System.

        Args:
            command (str): User Defined Command.

            remove_previous_execution_files (bool): Flag to indicate whether or not directories from
            previous runs should be removed from the `REPROPACK_BASE_PATH`.

        Returns:
            None:
        """
        # prepare commands to execute
        command = command.split()
        binary_command = command[0]

        # execute script with ReproZip (trace and pack)
        repropack_directory = reprozip_execute_script(self._reprofiles_directory, binary_command, command)

        # filter reprozip config file
        self._filter_input_files_in_config_file(repropack_directory)

        # pack!
        reprozip_pack_execution(repropack_directory)

        # store reprozip execution into the execution graph
        execution_metadata = reprozip_execution_metadata(repropack_directory, self._additional_working_directories)
        self._graph_manager.add_vertex(**execution_metadata)

        # save execution graph
        self._save_graph_manager(self._graph_manager)

        if remove_previous_execution_files:
            self._remove_unused_execution_files()

    def remake(self):  # what about this name ?
        """Remake the execution graph where vertices is `outdated`."""

        for vertex_index in self._graph_manager.graph.topological_sorting(mode="out"):
            vertex = self._graph_manager.graph.vs[vertex_index]

            if vertex["status"] == VertexStatus.Outdated:
                self.execute(vertex["command"])

    def reproduce(self):  # what about this name ?
        """Reproduce each of the operations of the execution graph in an isolated environment."""

        for vertex_index in self._graph_manager.graph.topological_sorting(mode="out"):
            vertex = self._graph_manager.graph.vs[vertex_index]

            print(f"Reproducing: {vertex['command']}")
            print(f"Checksum: {vertex['command_checksum']}")

            # setup the experiment using the reprounzip
            experiment_reproduction_path = os.path.join(mkdtemp(), "reproduction")

            (
                plumbum.cmd.reprounzip[
                    "docker", "setup", vertex["repropack"], experiment_reproduction_path
                ]
            )()

            # execute the experiment
            (
                plumbum.cmd.reprounzip[
                    "docker", "run", experiment_reproduction_path
                ]
            )()

            # download the results
            (
                plumbum.cmd.reprounzip[
                    "docker", "download", experiment_reproduction_path, "--all"
                ]
            )()


__all__ = (
    "ExecutionEngine"
)
