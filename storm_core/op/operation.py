# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 Storm Project.
#
# storm-core is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.

import os
import shutil
from pathlib import Path
from typing import List, Dict

from .mutator import GraphMutator
from ..execution.plan import ExecutionPlan
from ..index.model import ExecutionCompendium


class ReproducibleOperations:
    def __init__(self, execution_engine, execution_indexer):
        self._execution_engine = execution_engine
        self._execution_indexer = execution_indexer

        self._graph = self._execution_indexer.graph_manager.graph

    def _check_outdated_executions(self):
        # checking if the graph is outdated
        outdated_executions = list(
            self._execution_indexer.search.faceted.outdated_compendia()
        )
        if outdated_executions:
            raise RuntimeError(
                "There are Execution Compendia that are out of date. Update them before performing a new run."
            )

    def _remove_unused_execution_files(self):
        """Remove execution files that are not linked to any vertex."""
        # get files from execution directory

        execution_files_stored = os.listdir(
            self._execution_engine.files_config.storage_dir
        )

        # get the registered files
        execution_files_valid_on_graph = self._execution_indexer.graph_manager.to_frame(
            dim="vertex"
        )
        if len(execution_files_valid_on_graph):
            execution_files_valid_on_graph = execution_files_valid_on_graph["name"]

            # get the symmetric difference to define the files to remove
            execution_files_to_remove = set(
                execution_files_stored
            ).symmetric_difference(set(execution_files_valid_on_graph.tolist()))

            # remove the files
            for execution_file in execution_files_to_remove:
                shutil.rmtree(
                    Path(self._execution_engine.files_config.storage_dir)
                    / execution_file
                )

    def run(self, execution_plan: ExecutionPlan) -> List[ExecutionCompendium]:
        """Execute an experiment in a reproducible way.

        When the execution is done by the `Storm Workbench`, all computational components used on the execution will be
        registered transparently. With this, after the execution, the experiment can be reproduced without many efforts.
        For example, if you want to run a python script and then reproduce it, you can use `Storm Workbench` to help you.

        To do this, the execution that is normally done like this:

           $ python3 myscript.py

        with the Storm Workbench will look like this:

           $ workbench exec run python3 myscript.py

        The main difference here is that now, the execution is controlled by `Storm Workbench`, which allows you to extract
        information from the execution and save all the elements needed to reproduce the execution.

        Args:
            execution_plan (ExecutionPlan): Execution Plan object.

        Returns:
            List[ExecutionCompendium]: List with the ExecutionCompendium generated by the execution.

        Note:
            This command was created using the ReproZip tool. Many thanks to the ReproZip team.
        """
        self._check_outdated_executions()

        # Searching for previous output files (checksum)
        previous_output_checksum = self._execution_indexer.graph_manager.outputs
        execution_job_results = self._execution_engine.execute(
            execution_plan, states={"previous_outputs": previous_output_checksum}
        )

        # indexing the new done above.
        results = [
            self._execution_indexer.index_execution(
                ExecutionCompendium(
                    name=ec.execution_id,
                    command=ec.command,
                    metadata=ec.execution_results["metadata"],
                    compendium_package=ec.execution_results["compendium_package"],
                )
            )
            for ec in execution_job_results
        ]

        # removing outdated/invalid directories
        self._remove_unused_execution_files()

        return results

    def update(self):
        """Re-execute the Execution Compendia outdated.

        This command identifies and re-executes all outdated Execution Compendia, which is useful when multiple runs need
        to be updated because of changing results from other scripts. An execution is considered outdated when any of its
        predecessors have a run performed after its creation.

        For example, below we have three associated executions:

             *(Execution 1) -> *(Execution 2) -> *(Execution 3)

        All are up-to-date. If the `Execution 2` is executed again, all its subsequent ones will
        be out of date since they depend on the result generated by this Execution. Following this rule, in this
        example, the `Execution 3` is outdated.

        Returns:
            List[ExecutionCompendium]: List with the ExecutionCompendium updated by the execution.
        """
        _graph = self._execution_indexer.graph_manager.graph

        # preparing the outdated compendia that will be executed
        outdated_executions = list(
            self._execution_indexer.search.faceted.outdated_compendia()
        )
        outdated_compendia = [execution[0] for execution in outdated_executions]

        # mutating graph to execution plan
        execution_plan = (
            GraphMutator.mutate_graph_to_execution_plan_by_outdated_compendia(
                _graph,
                outdated_compendia,
                self._execution_engine.files_config.storage_dir,
            )
        )

        execution_result = []
        if execution_plan:
            previous_output_checksum = self._execution_indexer.graph_manager.outputs

            execution_job_results = self._execution_engine.execute(
                execution_plan, states={"previous_outputs": previous_output_checksum}
            )

            execution_result = [
                self._execution_indexer.index_execution(
                    ExecutionCompendium(
                        command=ec.command,
                        name=ec.execution_id,
                        metadata=ec.execution_results["metadata"],
                        compendium_package=ec.execution_results["compendium_package"],
                    )
                )
                for ec in execution_job_results
            ]

        # removing outdated/invalid directories
        self._remove_unused_execution_files()

        return execution_result

    def rerun(
        self,
        reproducible_storage: str,
        required_data_objects: Dict = None,
        required_environment_variables: List[str] = None,
    ):
        """"""
        self._check_outdated_executions()

        _graph = self._execution_indexer.graph_manager.graph
        execution_compendia = list(self._execution_indexer.search.query.query())

        execution_plan = GraphMutator.mutate_index_graph_to_compendia_job_graph(
            _graph, reproducible_storage, execution_compendia
        )

        # reproducing
        self._execution_engine.reproduce(
            execution_plan,
            required_data_objects or {},
            required_environment_variables or [],
        )
